# 깊이우선탐색(DFS)

## 1. 그래프 탐색 알고리즘

시작 정점에서 간선을 타고 이동할 수 있는 모든 정점을 찾는 알고리즘

깊이우선탐색 : 그래프의 깊이를 우선으로 탐색하기 위해 **스택**의 개념 활용

너비우선탐색 : 그래프의 너비를 우선으로 탐색하기 위해 **큐**의 개념 활용 

## 2. 깊이우선탐색(Depth-First Search)

- 시작 정점으로부터 갈 수 있는 하위 정점까지 가장 깊게 탐색하고, 더 이상 갈 곳이 없다면 마지막 갈림길로 돌아와서 다른 정점을 탐색하며 결국 모든 정점을 방문하는 순회 방법

![dfs](깊이우선탐색(DFS).assets/dfs.jpg)

- 미로 탈출과 유사 : 어느 한 쪽 길로 깊게 들어갔다가 막히면 다시 돌아와서 다른 길을 탐색
- 특징
  - 모든 정점을 방문할 때 유리, 경우의 수나 순열과 조합 문제에서 많이 사용
  - BFS에 비해 코드 구현이 간단
  - 단, 모든 정점을 방문할 필요가 없거나 최단 거리를 구하는 경우에는 BFS가 유리

## 3. DFS의 동작 과정

1. 탐색을 진행할 그래프를 인접 행렬 또는 인접 리스트 방식으로 표현

2. 각 정점을 방문했는지 여부를 판별할 방문 체크 리스트를 visited라는 불린 리스트로 만들어서 방문 시 True, 아닐 시 False로 값을 지정

3. DFS의 사이클

   1. 현재 정점 방문 처리

   2. 인접한 모든 정점 확인

   3. 방문하지 않은 인접 정점 이동

## 4. DFS 구현 방식

1. 그래프를 인접 리스트로 표현

```python
graph = [[1, 2], [0, 3, 4], [0, 4, 5], [1], [1, 2, 6], [2], [5]]
```

2. 직전에 방문한 정점으로 차례로 돌아가야 하므로 후입선출 구조의 스택을 사용

``` python
visited = [False] * n # 방문 처리 리스트, n은 정점의 개수
start = 0
n = len(graph)
stack = [start] # 시작 정점부터 방문 시작
visited[start] = True

while stack: # 스택이 비면 반복을 멈춤
    v = stack.pop() # 현재 방문한 정점
    print(v)
    for adj in graph[v]: # 인접한 모든 정점에 대해
        if not visited[adj]: # 방문하지 않았으면
            visited[adj] = True # 방문 처리하고 
            stack.append(adj) # 스택에 넣는다
```

