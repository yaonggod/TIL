# 시간 복잡도 & 빅오 표기법

## 알고리즘의 시간 복잡도

- 좋은 알고리즘이란? 효율성이 좋은 알고리즘? 성능이 좋은 알고리즘? 
  - 좋은 알고리즘 == *Input을 넣고 Output이 나오는 시간이 짧은 알고리즘*
- 개인의 컴퓨터에 따라 같은 알고리즘이라도 소요 시간이 다름 -> 객관적인 측정을 위해 알고리즘 내부에서 **기본 연산**이 몇 번 일어나는지 알아보기

- 기본연산 : 단위 시간 1이 소요되는 연산 ex) 할당, 산술, 비교, 반환, ...
  - 기본연산의 총 횟수 == 알고리즘의 소요 시간
  - 입력의 개수에 따라 시간이 달라짐 -> 성능을 측정할 때는 입력을 n으로 통일시킴

```python
def count(word, char):
    total = 0
    for i in word: # n (= len(word))번 반복
        if i == char:
            total += 1 # range(0, n + 1)번 더하기
    return total

count('apple', 'p') # n + 2번
count('aaaaa', 'a') # 2n번 (최악의 경우)
```

- 시간 복잡도(Time Complexity) : 단순히 알고리즘의 수행 시간을 의미
  - 시간 복잡도가 높을수록 느린 알고리즘, 낮을수록 빠른 알고리즘
  - 6n + 4, 3n + 2 -> 선형 증가
  - 3n^2 + 6n + 1 -> 제곱으로 증가

## 빅오(Big-O) 표기법

- 입력 n이 무한대로 커진다고 가정하고 시간 복잡도를 간단하게 표시하는 것
- 최고차항만 남기고 계수와 상수 제거, 정확한 수치보다는 증가율에 초점을 맞춤
  - 6n + 4, 3n + 2 -> O(n), 3n^2 + 6n + 1 -> O(n^2)
  - O(1) : 산술(+, -, *, /)
  - O(logN) : 이진탐색(Binary Search), 분할정복(Divide & Conquer)
  - O(N) : 리스트 순회, 1중 for문
  - O(NlogN) : 크기 N인 리스트를 반절씩 탐색 * 순회, Merge/Quick/Heap Sort
  - O(N^2) : 2중 리스트 순회, 2중 for문
  - O(N^3) : 3중 리스트 순회, 3중 for문
  - O(2^N) : 크기가 N인 집합의 부분 집합
  - O(N!) : 크기가 N인 순열
- [내장 함수, 메서드의 시간 복잡도](https://wiki.python.org/moin/TimeComplexity)도 확인